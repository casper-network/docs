"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8940],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=s(n),m=r,f=d["".concat(u,".").concat(m)]||d[m]||l[m]||o;return n?a.createElement(f,c(c({ref:t},p),{},{components:n})):a.createElement(f,c({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=d;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i.mdxType="string"==typeof e?e:r,c[1]=i;for(var s=2;s<o;s++)c[s]=n[s];return a.createElement.apply(null,c)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9332:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),c=["components"],i={},u="Smart Contract Upgrade Tutorial",s={unversionedId:"dapp-dev-guide/tutorials/upgrade-tutorial",id:"dapp-dev-guide/tutorials/upgrade-tutorial",title:"Smart Contract Upgrade Tutorial",description:"This tutorial shows you how to upgrade smart contracts. Casper contracts are upgradeable, making it easy for contract authors to add features and fix bugs in smart contracts.",source:"@site/source/docs/casper/dapp-dev-guide/tutorials/upgrade-tutorial.md",sourceDirName:"dapp-dev-guide/tutorials",slug:"/dapp-dev-guide/tutorials/upgrade-tutorial",permalink:"/docs/dapp-dev-guide/tutorials/upgrade-tutorial",editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/dapp-dev-guide/tutorials/upgrade-tutorial.md",tags:[],version:"current",frontMatter:{},sidebar:"dapp-dev-guide",previous:{title:"Additional Scenarios",permalink:"/docs/dapp-dev-guide/tutorials/multi-sig/additional"},next:{title:"Casper Signer in a dApp",permalink:"/docs/dapp-dev-guide/tutorials/casper-signer"}},p={},l=[{value:"Step 1. Deploy the contract with an &#39;upgrade&#39; function",id:"step-1-deploy-the-contract-with-an-upgrade-function",level:2},{value:"Step 2. Add an entry point in the &#39;call&#39; function",id:"step-2-add-an-entry-point-in-the-call-function",level:2},{value:"Step 3. Add new features",id:"step-3-add-new-features",level:2},{value:"External links",id:"external-links",level:2}],d={toc:l};function m(e){var t=e.components,n=(0,r.Z)(e,c);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"smart-contract-upgrade-tutorial"},"Smart Contract Upgrade Tutorial"),(0,o.kt)("p",null,"This tutorial shows you how to upgrade smart contracts. Casper contracts are upgradeable, making it easy for contract authors to add features and fix bugs in smart contracts."),(0,o.kt)("p",null,"The process of upgrading a smart contract is simple. All you need is to deploy a new version of the contract and overwrite the old functions with new ones."),(0,o.kt)("p",null,"These are the essential steps you need to follow:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Deploy the contract with an ",(0,o.kt)("em",{parentName:"li"},"upgrade")," function"),(0,o.kt)("li",{parentName:"ol"},"Add an entry point in the ",(0,o.kt)("em",{parentName:"li"},"call")," function for the ",(0,o.kt)("em",{parentName:"li"},"upgrade")," function"),(0,o.kt)("li",{parentName:"ol"},"Add the new features you desire")),(0,o.kt)("p",null,"Here are specific examples of how to implement the upgrade functionality."),(0,o.kt)("h2",{id:"step-1-deploy-the-contract-with-an-upgrade-function"},"Step 1. Deploy the contract with an 'upgrade' function"),(0,o.kt)("p",null,"When you first deploy the contract, you must include an ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function. Since the contract is immutable, you cannot add the ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function after deployment. Without the this function, you cannot upgrade the contract. In other words, you must include the ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function when you first deploy the contract."),(0,o.kt)("p",null,"Start by creating an ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function in your contract similar to the following example."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub extern "C" fn upgrade_me() {\n    let installer_package: ContractPackageHash = runtime::get_named_arg("installer_package");\n    let contract_package: ContractPackageHash = get_key(CONTRACT_PACKAGE);\n\n    runtime::call_versioned_contract(installer_package, None, "install", runtime_args! {\n    "contract_package" => contract_package,\n    })\n}\n')),(0,o.kt)("h2",{id:"step-2-add-an-entry-point-in-the-call-function"},"Step 2. Add an entry point in the 'call' function"),(0,o.kt)("p",null,"Next, you need to add an entry point to the ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function in the ",(0,o.kt)("em",{parentName:"p"},"call")," function. This enables the contract execution to invoke the ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function in the future."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub extern "C" fn call() {\n    let (contract_package, access_token) = storage::create_contract_package_at_hash();\n\n    let entry_points = {\n    let mut entry_points = EntryPoints::new();\n    let upgradefunction = EntryPoint::new(\n        "upgrade_me",\n        vec![],\n        CLType::Unit,\n        EntryPointAccess::Public,\n        EntryPointType::Contract,\n    );\n    entry_points.add_entry_point(upgradefunction);\n...\n    let mut named_keys = NamedKeys::new();\n    named_keys.insert(ACCESS_TOKEN.to_string(), access_token.into());\n    named_keys.insert(CONTRACT_PACKAGE.to_string(), storage::new_uref(contract_package).into());\n    let (new_contract_hash, _) = storage::add_contract_version(contract_package, entry_points, named_keys);\n\n    runtime::put_key(CONTRACT_NAME, new_contract_hash.into());\n    set_key(CONTRACT_PACKAGE, contract_package); // stores contract package hash under account\'s named key\n    set_key(CONTRACT_HASH, new_contract_hash);\n}\n')),(0,o.kt)("h2",{id:"step-3-add-new-features"},"Step 3. Add new features"),(0,o.kt)("p",null,"Now you are ready to upgrade your contract and add the new features and functions you desire."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Using the package hash and our access token, we\'re able to\n// upgrade our contract with new features and new functions\nlet contract_package: ContractPackageHash = runtime::get_named_arg(ARG_CONTRACT_PACKAGE); // Get the package hash of the first contract\nlet _access_token: URef = runtime::get_named_arg("accesstoken"); // Our secret access token, defined in the first version\n\nlet entry_points = {\nlet mut entry_points = EntryPoints::new();\nlet gettext = EntryPoint::new(\n    METHOD_SET_TEXT,\n    vec![],\n    CLType::Unit,\n    EntryPointAccess::Public,\n    EntryPointType::Contract,\n);\nentry_points.add_entry_point(gettext);\nentry_points\n};\n\n// Deploy the new version of the contract and replace the old functions with new one.\nlet (_, _) = storage::add_contract_version(contract_package.into(), entry_points, Default::deault());\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.add_contract_version.html"},"add_contract_version")," API will allow you to deploy a new version of your contract."),(0,o.kt)("p",null,"Remember, it is essential to include the ",(0,o.kt)("em",{parentName:"p"},"upgrade")," function and safeguard the access token when you first deploy the contract. You will need the access token for future upgrades."),(0,o.kt)("h2",{id:"external-links"},"External links"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For more sample code, check out this ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/casper-ecosystem/contract-upgrade-example"},"contract upgrade example")),(0,o.kt)("li",{parentName:"ul"},"The API details for adding a version are in ",(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/casper-contract/latest/casper_contract/contract_api/storage/fn.add_contract_version.html"},"add_contract_version")),(0,o.kt)("li",{parentName:"ul"},"Other examples of smart contracts can be found ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/casper-network/casper-node/tree/master/smart_contracts"},"here"))))}m.isMDXComponent=!0}}]);