"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8610],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),m=r,f=u["".concat(c,".").concat(m)]||u[m]||d[m]||a;return n?o.createElement(f,i(i({ref:t},p),{},{components:n})):o.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1970:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var o=n(3117),r=n(102),a=(n(7294),n(3905)),i=["components"],l={},c="Guidance for JSON-RPC SDK Compliance",s={unversionedId:"developers/json-rpc/guidance",id:"developers/json-rpc/guidance",title:"Guidance for JSON-RPC SDK Compliance",description:"A compliant Casper JSON-RPC SDK implementation must support all the endpoints and relevant types within the specification. The specification allows everything ranging from a minimal viable implementation to a full implementation, and a given SDK should cite which level of implementation they claim to be compliant with. For example, an SDK claiming to be an informational SDK must have implemented all entry points and relevant types described in the informational JSON-RPC methods page.",source:"@site/source/docs/casper/developers/json-rpc/guidance.md",sourceDirName:"developers/json-rpc",slug:"/developers/json-rpc/guidance",permalink:"/developers/json-rpc/guidance",draft:!1,editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/developers/json-rpc/guidance.md",tags:[],version:"current",lastUpdatedAt:1680534581,formattedLastUpdatedAt:"Apr 3, 2023",frontMatter:{},sidebar:"developers",previous:{title:"Introduction",permalink:"/developers/json-rpc/"},next:{title:"Required Methods for Minimal Compliance",permalink:"/developers/json-rpc/minimal-compliance"}},p={},u=[{value:"Consistency",id:"consistency",level:2},{value:"Advanced Functionality",id:"advanced-functionality",level:2}],d={toc:u},m="wrapper";function f(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)(m,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"guidance-for-json-rpc-sdk-compliance"},"Guidance for JSON-RPC SDK Compliance"),(0,a.kt)("p",null,"A compliant Casper JSON-RPC SDK implementation must support all the endpoints and relevant types within the specification. The specification allows everything ranging from a minimal viable implementation to a full implementation, and a given SDK should cite which level of implementation they claim to be compliant with. For example, an SDK claiming to be an informational SDK must have implemented all entry points and relevant types described in the ",(0,a.kt)("a",{parentName:"p",href:"/developers/json-rpc/json-rpc-informational"},"informational JSON-RPC methods")," page."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"A Casper JSON-RPC SDK claiming to be complete is expected to implement ",(0,a.kt)("em",{parentName:"strong"},"all")," endpoints and ",(0,a.kt)("em",{parentName:"strong"},"all")," types defined in the serialization standard.")),(0,a.kt)("h2",{id:"consistency"},"Consistency"),(0,a.kt)("p",null,"A Casper JSON-RPC SDK must be consistent in terminology, language, and functionality relative to the Casper platform's architecture and design. Use actual terms such as Account and Deploy, not similar terms such as wallet or transaction."),(0,a.kt)("p",null,"Care should be taken to maintain a universal language and not obscure the domain concepts of the Casper platform, which could confuse users of the SDK. The goal is to not make it difficult for users of an SDK to understand the documentation of the Casper platform. Further, they should be able to communicate effectively with technical support personnel who understand the terminology of the Casper platform and not the variant terminology of an SDK."),(0,a.kt)("h2",{id:"advanced-functionality"},"Advanced Functionality"),(0,a.kt)("p",null,"SDK developers are allowed and encouraged to add convenience methods, supporting utilities, domain specific or macro support and extended functionality using the available endpoints and possible combinations."),(0,a.kt)("p",null,"However, it is critical that SDK developers avoid misleading or improperly characterizing the purpose and scope of the available endpoints. Custom functionality should improve on the basic building blocks of the Casper Platform, offering added convenience."),(0,a.kt)("p",null,"For example, some languages have strong idiomatic opinions and programmers using those languages are comfortable with or even expect SDKs in that language to follow those idioms. This is acceptable, as long as they do not obfuscate underlying terminology or semantics of the Casper platform."))}f.isMDXComponent=!0}}]);