"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2852],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=l(n),h=a,d=m["".concat(c,".").concat(h)]||m[h]||u[h]||s;return n?r.createElement(d,o(o({ref:t},p),{},{components:n})):r.createElement(d,o({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1854:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var r=n(7462),a=n(3366),s=(n(7294),n(3905)),o=["components"],i={},c="Testing Framework",l={unversionedId:"dapp-dev-guide/tutorials/erc20/tests",id:"dapp-dev-guide/tutorials/erc20/tests",title:"Testing Framework",description:"The testing framework in this tutorial uses the Casper engine test support crate for testing the contract implementation against the Casper execution environment.",source:"@site/source/docs/casper/dapp-dev-guide/tutorials/erc20/tests.md",sourceDirName:"dapp-dev-guide/tutorials/erc20",slug:"/dapp-dev-guide/tutorials/erc20/tests",permalink:"/docs/dapp-dev-guide/tutorials/erc20/tests",editUrl:"https://github.com/casper-network/docs/tree/main/source/docs/casper/dapp-dev-guide/tutorials/erc20/tests.md",tags:[],version:"current",frontMatter:{},sidebar:"dapp-dev-guide",previous:{title:"Contract Deployment",permalink:"/docs/dapp-dev-guide/tutorials/erc20/deploy"},next:{title:"The NFT Standard on Casper (CEP-47)",permalink:"/docs/dapp-dev-guide/tutorials/cep47/"}},p=[{value:"Configuring the Test Package",id:"configuring-the-test-package",children:[],level:2},{value:"Testing Logic",id:"testing-logic",children:[{value:"Setting up the testing context",id:"setting-up-the-testing-context",children:[],level:3},{value:"Deploying the contract",id:"deploying-the-contract",children:[],level:3},{value:"Querying the network",id:"querying-the-network",children:[],level:3},{value:"Invoking contract methods",id:"invoking-contract-methods",children:[],level:3}],level:2},{value:"Creating Unit Tests",id:"creating-unit-tests",children:[],level:2},{value:"Running the Tests",id:"running-the-tests",children:[],level:2}],u={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"testing-framework"},"Testing Framework"),(0,s.kt)("p",null,"The testing framework in this tutorial uses the ",(0,s.kt)("a",{parentName:"p",href:"https://crates.io/crates/casper-engine-test-support"},"Casper engine test support")," crate for testing the contract implementation against the Casper execution environment."),(0,s.kt)("p",null,"We will review the following three ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/tree/master/testing"},"GitHub testing folders"),", which create a testing framework for the Casper ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20"},"ERC-20")," project:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"erc20-test-call")," - Links the test framework together and is required by the Rust toolchain"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"erc20-test")," - Sets up the testing context and creates helper functions used by unit tests"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"tests")," - Contains the unit tests")),(0,s.kt)("p",null,"The following is an example of a complete test:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'\n    #[should_panic(expected = "ApiError::User(65534) [131070]")]\n    #[test]\n    fn should_not_transfer_with_insufficient_balance() {\n        let mut fixture = TestFixture::install_contract();\n\n        let initial_ali_balance = fixture.balance_of(Key::from(fixture.ali)).unwrap();\n        assert_eq!(fixture.balance_of(Key::from(fixture.bob)), None);\n\n        fixture.transfer(\n            Key::from(fixture.bob),\n            initial_ali_balance + U256::one(),\n            Sender(fixture.ali),\n        );\n    }\n')),(0,s.kt)("p",null,"To run the tests, issue the following command in the project folder, ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20"},"erc20"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"\n    make test\n\n")),(0,s.kt)("p",null,"The project contains a ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/Makefile"},"Makefile"),", which is a custom build script that compiles the contract before running tests in ",(0,s.kt)("em",{parentName:"p"},"release")," mode. Then, the script copies the ",(0,s.kt)("inlineCode",{parentName:"p"},"contract.wasm")," file to the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/tree/master/testing/tests/wasm"},"tests/wasm")," directory. In practice, you only need to run the ",(0,s.kt)("inlineCode",{parentName:"p"},"make test")," command during development."),(0,s.kt)("h2",{id:"configuring-the-test-package"},"Configuring the Test Package"),(0,s.kt)("p",null,"In this project, we define a ",(0,s.kt)("inlineCode",{parentName:"p"},"tests")," package using the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/testing/tests/Cargo.toml"},"tests/Cargo.toml")," file."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'\n    [package]\n    name = "tests"\n    version = "0.1.0"\n    ...\n\n    [dependencies]\n    casper-types = "1.3.2"\n    casper-engine-test-support = "1.3.2"\n    casper-execution-engine = "1.3.2"\n    once_cell = "1.8.0"\n\n    [lib]\n    name = "tests"\n    ...\n')),(0,s.kt)("h2",{id:"testing-logic"},"Testing Logic"),(0,s.kt)("p",null,"In Github, you will find an ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/tree/master/example"},"example")," containing a Casper ERC-20 ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-token/src/main.rs"},"contract")," implementation with the corresponding ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/tree/master/example/erc20-tests/src"},"tests"),". The tests follow this sequence:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#setting-up-the-testing-context"},"Step 1")," - Specify the starting state of the blockchain."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#deploying-the-contract"},"Step 2")," - Deploy the compiled contract to the blockchain and query it."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#invoking-contract-methods"},"Step 3")," - Create additional deploys for each of the methods in the contract.")),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs"},"TestFixture")," accomplishes these steps by simulating a real-world deployment (storing the contract in the blockchain) and invoking methods in the contract."),(0,s.kt)("h3",{id:"setting-up-the-testing-context"},"Setting up the testing context"),(0,s.kt)("p",null,"The code in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs"},"TestFixture")," initializes the blockchain's ",(0,s.kt)("a",{parentName:"p",href:"/docs/glossary/G#global-state"},"global state")," with all the data and methods a smart contract needs."),(0,s.kt)("p",null,"Below is a subset of the required constants for this project. For the most up-to-date version of the code, visit ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20"},"GitHub"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'\n    // File https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs\n\n    use casper_engine_test_support::{Code, SessionBuilder, TestContext, TestContextBuilder};\n    use casper_erc20::constants as consts;\n    use casper_types::{\n        account::AccountHash,\n        bytesrepr::{FromBytes, ToBytes},\n        runtime_args, AsymmetricType, CLTyped, ContractHash, Key, PublicKey, RuntimeArgs, U256, U512,\n    };\n\n    const CONTRACT_ERC20_TOKEN: &str = "erc20_token.wasm";\n    const CONTRACT_KEY_NAME: &str = "erc20_token_contract";\n\n    fn blake2b256(item_key_string: &[u8]) -> Box<[u8]> {...}\n\n    #[derive(Clone, Copy)]\n    pub struct Sender(pub AccountHash);\n    ...\n\n')),(0,s.kt)("h3",{id:"deploying-the-contract"},"Deploying the contract"),(0,s.kt)("p",null,"The next step is to define a struct that has its own virtual machine (VM) instance and implements the ERC-20 methods. This struct holds a ",(0,s.kt)("inlineCode",{parentName:"p"},"TestContext")," of its own. The ",(0,s.kt)("em",{parentName:"p"},"contract_hash")," and the ",(0,s.kt)("em",{parentName:"p"},"session_code")," won\u2019t change after the contract is deployed, so it is good to keep them handy."),(0,s.kt)("p",null,"This code snippet builds the context and includes the compiled contract ",(0,s.kt)("em",{parentName:"p"},".wasm")," binary being tested. The ",(0,s.kt)("inlineCode",{parentName:"p"},"TestFixture")," struct creates a new instance of the ",(0,s.kt)("inlineCode",{parentName:"p"},"CONTRACT_ERC20_TOKEN")," with the following accounts:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ali")," - account used to deploy the contract"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"bob")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"joe"))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Note"),": These accounts have a positive initial balance."),(0,s.kt)("p",null,"The full and most recent code implementation is available on ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs"},"GitHub"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'\n    // File https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs\n\n    pub struct TestFixture {\n        context: TestContext,\n        pub ali: AccountHash,\n        pub bob: AccountHash,\n        pub joe: AccountHash,\n    }\n\n    impl TestFixture {\n        pub const TOKEN_NAME: &\'static str = "Test ERC20";\n        pub const TOKEN_SYMBOL: &\'static str = "TERC";\n        pub const TOKEN_DECIMALS: u8 = 8;\n        const TOKEN_TOTAL_SUPPLY_AS_U64: u64 = 1000;\n\n        pub fn token_total_supply() -> U256 {\n            Self::TOKEN_TOTAL_SUPPLY_AS_U64.into()\n        }\n\n        pub fn install_contract() -> TestFixture {\n            let ali = PublicKey::ed25519_from_bytes([3u8; 32]).unwrap();\n            let bob = PublicKey::ed25519_from_bytes([6u8; 32]).unwrap();\n            let joe = PublicKey::ed25519_from_bytes([9u8; 32]).unwrap();\n\n            let mut context = TestContextBuilder::new()\n                .with_public_key(ali.clone(), U512::from(500_000_000_000_000_000u64))\n                .with_public_key(bob.clone(), U512::from(500_000_000_000_000_000u64))\n                .build();\n\n            let session_code = Code::from(CONTRACT_ERC20_TOKEN);\n            let session_args = runtime_args! {\n                consts::NAME_RUNTIME_ARG_NAME => TestFixture::TOKEN_NAME,\n                consts::SYMBOL_RUNTIME_ARG_NAME => TestFixture::TOKEN_SYMBOL,\n                consts::DECIMALS_RUNTIME_ARG_NAME => TestFixture::TOKEN_DECIMALS,\n                consts::TOTAL_SUPPLY_RUNTIME_ARG_NAME => TestFixture::token_total_supply()\n            };\n\n            let session = SessionBuilder::new(session_code, session_args)\n                .with_address(ali.to_account_hash())\n                .with_authorization_keys(&[ali.to_account_hash()])\n                .build();\n\n            context.run(session);\n            TestFixture {\n                context,\n                ali: ali.to_account_hash(),\n                bob: bob.to_account_hash(),\n                joe: joe.to_account_hash(),\n            }\n        }\n')),(0,s.kt)("h3",{id:"querying-the-network"},"Querying the network"),(0,s.kt)("p",null,"The previous step has simulated a real deploy on the network. The next code snippet describes how to query the network to find the ",(0,s.kt)("em",{parentName:"p"},"contract hash"),"."),(0,s.kt)("p",null,"Contracts are deployed under the context of an account. Since we created the deploy under the context of ",(0,s.kt)("inlineCode",{parentName:"p"},"self.ali"),", this is what we will query next. The ",(0,s.kt)("inlineCode",{parentName:"p"},"query_contract")," function uses ",(0,s.kt)("inlineCode",{parentName:"p"},"query")," to lookup named keys. It will be used to implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"balance_of"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"total_supply")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"allowance")," checks."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'\n    fn contract_hash(&self) -> ContractHash {\n        self.context\n            .get_account(self.ali)\n            .unwrap()\n            .named_keys()\n            .get(CONTRACT_KEY_NAME)\n            .unwrap()\n            .normalize()\n            .into_hash()\n            .unwrap()\n            .into()\n    }\n\n    fn query_contract<T: CLTyped + FromBytes>(&self, name: &str) -> Option<T> {\n        match self\n            .context\n            .query(self.ali, &[CONTRACT_KEY_NAME.to_string(), name.to_string()])\n        {\n            Err(_) => None,\n            Ok(maybe_value) => {\n                let value = maybe_value\n                    .into_t()\n                    .unwrap_or_else(|_| panic!("{} is not expected type.", name));\n                Some(value)\n            }\n        }\n    }\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Helper Functions")),(0,s.kt)("p",null,"The following helper functions are defined to query the named keys in the contract."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"token_name")," function returns the name of the token:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    pub fn token_name(&self) -> String {\n        self.query_contract(consts::NAME_RUNTIME_ARG_NAME).unwrap()\n    }\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"token_symbol")," function returns the token symbol:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    pub fn token_symbol(&self) -> String {\n        self.query_contract(consts::SYMBOL_RUNTIME_ARG_NAME)\n            .unwrap()\n    }\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"token_decimals")," function returns the number of decimal places for the token:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    pub fn token_decimals(&self) -> u8 {\n        self.query_contract(consts::DECIMALS_RUNTIME_ARG_NAME)\n            .unwrap()\n    }\n")),(0,s.kt)("h3",{id:"invoking-contract-methods"},"Invoking contract methods"),(0,s.kt)("p",null,"The following code snippet describes a generic way to call a specific entry point in the contract."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    fn call(&mut self, sender: Sender, method: &str, args: RuntimeArgs) {\n        let Sender(address) = sender;\n        let code = Code::Hash(self.contract_hash().value(), method.to_string());\n        let session = SessionBuilder::new(code, args)\n            .with_address(address)\n            .with_authorization_keys(&[address])\n            .build();\n        self.context.run(session);\n    }\n")),(0,s.kt)("p",null,"The next code sample shows how to invoke one of the methods in the contract. The rest of the methods are available on ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs"},"GitHub"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    pub fn balance_of(&self, account: Key) -> Option<U256> {\n        let item_key = base64::encode(&account.to_bytes().unwrap());\n\n        let key = Key::Hash(self.contract_hash().value());\n        let value = self\n            .context\n            .query_dictionary_item(key, Some(consts::BALANCES_KEY_NAME.to_string()), item_key)\n            .ok()?;\n\n        Some(value.into_t::<U256>().unwrap())\n    }\n")),(0,s.kt)("h2",{id:"creating-unit-tests"},"Creating Unit Tests"),(0,s.kt)("p",null,"Now that we have a testing context, we can use it to create unit tests in a file called ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/integration_tests.rs"},"integration_tests.rs"),". The unit tests verify the contract code by invoking the functions defined in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/test_fixture.rs"},"test_fixture.rs")," file."),(0,s.kt)("p",null,"The example below shows one of the example tests. Visit ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/integration_tests.rs"},"GitHub")," to find all the available tests."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    // File https://github.com/casper-ecosystem/erc20/blob/master/example/erc20-tests/src/integration_tests.rs\n\n    use casper_types::{Key, U256};\n\n    use crate::test_fixture::{Sender, TestFixture};\n\n    #[test]\n    fn should_install() {\n        let fixture = TestFixture::install_contract();\n        assert_eq!(fixture.token_name(), TestFixture::TOKEN_NAME);\n        assert_eq!(fixture.token_symbol(), TestFixture::TOKEN_SYMBOL);\n        assert_eq!(fixture.token_decimals(), TestFixture::TOKEN_DECIMALS);\n        assert_eq!(\n            fixture.balance_of(Key::from(fixture.ali)),\n            Some(TestFixture::token_total_supply())\n        );\n    }\n")),(0,s.kt)("h2",{id:"running-the-tests"},"Running the Tests"),(0,s.kt)("p",null,"We have configured the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20/blob/master/testing/tests/src/lib.rs"},"lib.rs")," file to run the example integration tests via the ",(0,s.kt)("inlineCode",{parentName:"p"},"make test")," command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"\n    #[cfg(test)]\n    mod lib_integration_tests;\n")),(0,s.kt)("p",null,"To run the tests, navigate to the parent ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/erc20"},"erc20 directory")," and run the command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"\n    make test\n\n")),(0,s.kt)("p",null,"This example uses ",(0,s.kt)("inlineCode",{parentName:"p"},"bash"),". If you are using a Rust IDE, you need to configure it to run the tests."))}m.isMDXComponent=!0}}]);