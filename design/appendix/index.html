<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<title data-react-helmet="true">Appendix | Casper</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://operators.casper.network//docs/design/appendix"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Appendix | Casper"><meta data-react-helmet="true" name="description" content="appendix-head}"><meta data-react-helmet="true" property="og:description" content="appendix-head}"><link data-react-helmet="true" rel="icon" href="/docs/image/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://operators.casper.network//docs/design/appendix"><link data-react-helmet="true" rel="alternate" href="https://operators.casper.network//docs/design/appendix" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://operators.casper.network//docs/design/appendix" hreflang="x-default"><link rel="stylesheet" href="/docs/assets/css/styles.5017e055.css">
<link rel="preload" href="/docs/assets/js/runtime~main.42631c81.js" as="script">
<link rel="preload" href="/docs/assets/js/main.b30bf4af.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs/"><div class="navbar__logo"><img src="/docs/icon/logo-dark.svg" alt="Casper Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/docs/icon/logo-white.svg" alt="Casper Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title"></b></a><a class="navbar__item navbar__link" href="/docs/workflow">How To&#x27;s</a><a class="navbar__item navbar__link" href="/docs/dapp-dev-guide">Developers</a><a class="navbar__item navbar__link" href="/docs/operators">Operators</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/design">Design</a><a class="navbar__item navbar__link" href="/docs/economics">Economics</a><a class="navbar__item navbar__link" href="/docs/staking">Staking</a><a class="navbar__item navbar__link" href="/docs/glossary">Glossary</a><a class="navbar__item navbar__link" href="/docs/faq">FAQ</a><a href="https://discord.gg/casperblockchain" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>Chat<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link"><span><svg viewBox="0 0 20 20" width="20" height="20" aria-hidden="true" class="iconLanguage_EbrZ"><path fill="currentColor" d="M19.753 10.909c-.624-1.707-2.366-2.726-4.661-2.726-.09 0-.176.002-.262.006l-.016-2.063 3.525-.607c.115-.019.133-.119.109-.231-.023-.111-.167-.883-.188-.976-.027-.131-.102-.127-.207-.109-.104.018-3.25.461-3.25.461l-.013-2.078c-.001-.125-.069-.158-.194-.156l-1.025.016c-.105.002-.164.049-.162.148l.033 2.307s-3.061.527-3.144.543c-.084.014-.17.053-.151.143.019.09.19 1.094.208 1.172.018.08.072.129.188.107l2.924-.504.035 2.018c-1.077.281-1.801.824-2.256 1.303-.768.807-1.207 1.887-1.207 2.963 0 1.586.971 2.529 2.328 2.695 3.162.387 5.119-3.06 5.769-4.715 1.097 1.506.256 4.354-2.094 5.98-.043.029-.098.129-.033.207l.619.756c.08.096.206.059.256.023 2.51-1.73 3.661-4.515 2.869-6.683zm-7.386 3.188c-.966-.121-.944-.914-.944-1.453 0-.773.327-1.58.876-2.156a3.21 3.21 0 011.229-.799l.082 4.277a2.773 2.773 0 01-1.243.131zm2.427-.553l.046-4.109c.084-.004.166-.01.252-.01.773 0 1.494.145 1.885.361.391.217-1.023 2.713-2.183 3.758zm-8.95-7.668a.196.196 0 00-.196-.145h-1.95a.194.194 0 00-.194.144L.008 16.916c-.017.051-.011.076.062.076h1.733c.075 0 .099-.023.114-.072l1.008-3.318h3.496l1.008 3.318c.016.049.039.072.113.072h1.734c.072 0 .078-.025.062-.076-.014-.05-3.083-9.741-3.494-11.04zm-2.618 6.318l1.447-5.25 1.447 5.25H3.226z"></path></svg><span>English</span></span></a><ul class="dropdown__menu"><li><a href="/docs/design/appendix" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active">English</a></li></ul></div><a href="https://github.com/casper-network/docs-app" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ğŸŒ™</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ğŸŒ</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/p2p">Network Communication</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/global-state">Global State</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/execution-semantics">Execution Semantics</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/accounts">Accounts</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/block-structure">Block Structure</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/uref">Unforgeable Reference (URef)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/serialization-standard">Serialization Standard</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/tokens">Tokens</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design/checksummed-hex">Checksum Hex Encoding</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/design/appendix">Appendix</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_eoK2"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_e+kA"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Appendix</h1></header><h2 class="anchor anchorWithStickyNavbar_y2LR" id="appendix-a">A - Casper Rust Library<a class="hash-link" href="#appendix-a" title="Direct link to heading">â€‹</a></h2><p>Casper provides low-level bindings for host-side (&quot;external&quot;) functions for developers creating smart contracts in other programming languages. Developers can import these functions into a wasm module used as a contract on the Casper Network. Thus, the contract will have access to features specific to the Casper platform which are not supported by general wasm instructions (e.g., accessing the global state, creating new <code>URef</code>s). These are defined and automatically imported if the <a href="https://crates.io/crates/casper-contract" target="_blank" rel="noopener noreferrer">Casper Rust library</a> is used to develop the contract. For an up-to-date description of exported functions, please visit the <a href="https://docs.rs/casper-contract/latest/casper_contract/ext_ffi/index.html" target="_blank" rel="noopener noreferrer">casper-contract</a> crate documentation.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="appendix-b">B - Serialization Format<a class="hash-link" href="#appendix-b" title="Direct link to heading">â€‹</a></h2><p>The Casper serialization format is used to transfer data between wasm and the Casper host runtime. It is also used to persist global-state data in the Merkle trie. The definition of this format is described in the <a href="/docs/design/global-state#global-state-head">global state</a> section.</p><p>A Rust reference implementation for those implementing this specification in another programming language can be found here:</p><ul><li><a href="https://docs.rs/casper-types/latest/casper_types/bytesrepr/index.html" target="_blank" rel="noopener noreferrer">bytesrepr</a></li><li><a href="https://docs.rs/casper-types/latest/src/casper_types/cl_value.rs.html" target="_blank" rel="noopener noreferrer">cl_value.rs</a></li><li><a href="https://docs.rs/casper-types/latest/casper_types/account/index.html" target="_blank" rel="noopener noreferrer">account</a></li><li><a href="https://docs.rs/casper-types/latest/casper_types/contracts/struct.Contract.html" target="_blank" rel="noopener noreferrer">contract</a></li><li><a href="https://docs.rs/casper-types/latest/src/casper_types/uint.rs.html" target="_blank" rel="noopener noreferrer">uint.rs</a></li></ul><p>Additionally, examples of all data types and their serializations are found in the <a href="https://github.com/casper-network/casper-node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26" target="_blank" rel="noopener noreferrer">GitHub code base</a>. These examples include a set of useful <a href="https://github.com/casper-network/casper-node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189" target="_blank" rel="noopener noreferrer">serialization tests</a>.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="appendix-c">C - Parallel Execution<a class="hash-link" href="#appendix-c" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">â€‹</a></h3><p>The state of the Casper Network is represented by the <a href="/docs/design/global-state#global-state-head">global state</a>. The evolution of this state is captured by the blockchain itself, and eventually agreed upon by all nodes in the network via the consensus mechanism. In this section we are concerned with only a single step of that evolution. We think of such a step as performing some &quot;computation&quot; that changes the global state. A <a href="/docs/design/execution-semantics#execution-semantics-deploys">deploy</a> is a user request for computation, and contains two atomic units of computation: the payment code and the session code (the details of which are discussed elsewhere). For the purpose of this section, we think of each of these units as a (mathematical) function which takes the current global state as input, perhaps along with some other arguments, and produces a new global state as output. However, since the overall global state is ambient from the perspective of the session/payment code itself, the global state is not an explicit parameter in any user&#x27;s source code, nor is there any explicit return value.</p><p>In this section we refine this idea of computation modeled as functions, and describe how it is used to enable parallel execution.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="computational-model-functions">Computation as functions on the global state<a class="hash-link" href="#computational-model-functions" title="Direct link to heading">â€‹</a></h3><p>As discussed in the introduction, we think of computation on the Casper platform as being functions from the global state, <strong><em>G</em></strong>, to itself. Naturally, we can compose two such functions, to obtain another function. This corresponds to sequential execution. For example, you can think of the sequence <code>payment_code -&gt; session_code</code> as being the composition of two individual functions, capturing the effects of the payment and session codes, respectively. If there are smart contracts which are called during those execution phases, you could even break these down further into a sequence of those calls: <code>deployed_payment_wasm -&gt; contract_a -&gt; contract_b -&gt; stored_session_code -&gt; contract_c -&gt; ...</code>. For notational purposes, we will call the set of functions <code>{ğ‘“ | ğ‘“:ğºâ†’ğº}=ğ¸ğ‘›ğ‘‘(ğº)</code>, meaning &quot;endomorphisms of <strong><em>G</em></strong>&quot;.</p><p>While this simple model captures sequential execution, it does not model parallel execution. Parallel execution is important because it can enable the execution engine to run more than one deploy at the same time, possibly improving block processing times. Note: each deploy itself is still single-threaded; we will not support parallel execution within a single contract or deploy. This optimization is purely for the performance of the node implementation, not contract developers.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="computation-as-functions-from-g-to-endg">Computation as functions from <strong><em>G</em></strong> to <strong><em>End(G)</em></strong><a class="hash-link" href="#computation-as-functions-from-g-to-endg" title="Direct link to heading">â€‹</a></h3><p>The problem with functions on the global state itself is they mutate the state, potentially causing problems if we wanted to apply two such functions at the same time. Therefore, we will instead think of computations as outputting a description of the changes to the global state that they would make if given the chance. Or phrased another way, the execution of a deploy will return a function that could be applied to the global state to obtain the post-state we would have obtained from running the computation while mutating the global state. The reason this helps is because we can apply multiple such functions to the same global state at the same time; they are pure functions that do not modify the global state. Thus we can execute multiple deploys in parallel and later combine their outputs (more on this later).</p><p>The way this is modeled in the Casper execution engine is via the <a href="https://github.com/casper-network/casper-node/blob/master/execution_engine/src/core/tracking_copy/mod.rs" target="_blank" rel="noopener noreferrer">TrackingCopy</a>. Executing deploys (and the contracts they call) read/write from the <a href="https://github.com/casper-network/casper-node/blob/master/execution_engine/src/core/tracking_copy/mod.rs" target="_blank" rel="noopener noreferrer">TrackingCopy</a> instead of the global state directly. The <a href="https://github.com/casper-network/casper-node/blob/master/execution_engine/src/core/tracking_copy/mod.rs" target="_blank" rel="noopener noreferrer">TrackingCopy</a> <em>tracks</em> the operations and returns the <code>Transform</code>s which act on each key in the global state effected by the execution. Using the nomenclature from the theory, this collection of keys and transforms describes a function ğ‘“ : ğº â†’ ğº which is an endomorphism on <strong><em>G</em></strong>, i.e. an element of <strong><em>End(G)</em></strong>.</p><p>An important note about the returned <code>Transform</code>s is there is exactly one <code>Transform</code> per key that was used during the execution. Initially, this may be unintuitive because a contract can use the same key multiple times, however, because each deploy executes sequentially, we can use the composition property discussed in the previous section to combine multiple sequential operations into a single operation. Consider the following example.</p><div class="codeBlockContainer_J+bg language-rust theme-code-block"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// an implementation of the function featured in the Collatz conjecture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let n = read_local(&quot;n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let f_n =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if n % 2 == 0 { n / 2 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else { 3 * n + 1 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">write_local(&quot;n&quot;, f_n);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>The above function reads a local variable, performs a computation which depends on the current value of that variable, then writes an updated value. Suppose we execute this function on a global state where the value of the local key is <code>7</code>. Then the sequence of transforms on the global state would be <code>Read -&gt; Write(22)</code> since <code>n</code> would be odd and thus <code>f_n</code> would be computed using the <code>else</code> case. From the perspective of state changes, we only need to keep the <code>Write(22)</code> transform because final state is the same as if we had also included the <code>Read</code> transform. In fact, by the same reasoning, we know that we only need to keep the last <code>Write</code>, whatever it happens to be, since it will be the final value on the key after the computation finishes. Notice that the resulting global state function does not exactly reproduce the original contract execution steps; it is a <em>reduced trace</em> where only the final effect on the global state is recorded <sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>. In particular, this means applying the results of these executions is very fast relative to the original execution (this will be important for how we use these traces in the next section). Also notice that the transforms which are produced depend on the initial state. This might be obvious since we are modeling computation as functions <strong><em>ğ‘“:ğºâ†’ğ¸ğ‘›ğ‘‘(ğº)</em></strong>, so this statement is simply that the function really depends on its input. However, this is again an important concept to keep in mind when working with this model of computation. Going back to our example, if the value of the local key was <code>16</code> then the transform produced would be <code>Write(8)</code>, entirely different from the case where the initial value was <code>7</code>.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="constructing-the-post-state-from-parallel-execution">Constructing the post-state from parallel execution<a class="hash-link" href="#constructing-the-post-state-from-parallel-execution" title="Direct link to heading">â€‹</a></h3><p>Following from the previous section, we know that deploys execute to produce a <code>Map&lt;Key, Transform&gt;</code> which gives a summary (i.e. &quot;reduced trace&quot;) of the effects the deploy would have had on each key in the global state (keys not present in the map are not effected). In the reference implementation we call this the <code>exec</code> phase. Since creating these maps does not mutate the global state, we can run as many of these as we want in parallel. However, after they have been run we need to actually produce a post-state, the new global state after applying the effects of the deploys (this will then be used as the pre-states for deploys in the following batch of executions). In the reference implementation, we call applying the collection of transforms to obtain a post-state the <code>commit</code> phase.</p><p>Before we can construct the post-state, we must know that one is well-defined. When working with parallel execution with a shared resource, you may encounter &quot;race conditions&quot;. This is a situation where the outcome of a parallel computation depends on the order or timing of events, in particular when this timing is not explicitly controlled. Or phrased another way, parallelism with a shared resource is a lie and one of the processes will use the resource first, followed by the other one. A classic blockchain example of a race condition is a double spend (which under an accounts model, as opposed to UTXO, is the same as an overdraft on the account); one payer attempts to pay two payees at the same time without enough tokens to actually pay both. One payee or the other is not getting their tokens, depending on the order the transactions are processed.</p><p>In our simple model of computation where deploys are functions on the global state, this would correspond to functions that do not <em>commute</em>, that is to say, the order in which we apply the functions to the global state matters: ğ‘“âˆ˜ğ‘”â‰ ğ‘”âˆ˜ğ‘“ . Therefore, in order to prevent race conditions, we will only allow deploys to execute in parallel if they commute. Taking our more sophisticated model of computation, we have two deploys: ğ‘“:ğºâ†’ğ¸ğ‘›ğ‘‘(ğº) and ğ‘”:ğºâ†’ğ¸ğ‘›ğ‘‘(ğº), and we will only allow both be committed to the same pre-state <strong><em>G</em></strong> if ğ‘“(ğº)âˆ˜ğ‘”(ğº)=ğ‘”(ğº)âˆ˜ğ‘“(ğº), i.e. the resulting maps of transforms commute.</p><p>We will discuss how to compute whether two maps of transforms commute in the next section. For now, we assume that run some set of deploys <strong>d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, ...</strong> in parallel against a fixed pre-state <strong><em>G</em></strong> to obtain a set of transform maps <strong>T<sub>1</sub>, T<sub>2</sub>, T<sub>3</sub>, ...</strong>, then select only the transforms that commute <strong>T<sub>i</sub>, T<sub>j</sub>, T<sub>k</sub>, ...</strong> to apply to <strong><em>G</em></strong>, and thus obtain the post-state <strong><em>ğºâ€²</em></strong>. The remaining deploys we can all run in parallel against <strong><em>ğºâ€²</em></strong>, again choosing the commuting ones to commit, obtaining <strong><em>ğºâ€²â€²</em></strong>, and so on. This final post-state is the same as if we had run all the deploys <strong>d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>, ...</strong> in sequence against <strong><em>G</em></strong>, but perhaps faster (depending on how many could commute<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>) because we were able to run in parallel batches.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="detecting-when-maps-of-transforms-commute">Detecting when maps of transforms commute<a class="hash-link" href="#detecting-when-maps-of-transforms-commute" title="Direct link to heading">â€‹</a></h3><p>Two transform maps <code>m_1: Map&lt;Key, Transform&gt;</code> and <code>m_2: Map&lt;Key,Transform&gt;</code> commute if for all keys <code>k</code> which are present in both maps, the transforms <code>t_1 = m_1[k]</code> and <code>t_2 = m_2[k]</code> commute. Notably, if there are no such keys then the maps trivially commute. Two transforms <code>t_1:Transform</code> and <code>t_2: Transform</code> commute if:</p><ul><li><code>t_1 == t_2 == Read</code></li><li><code>t_1</code> and <code>t_2</code> are both of the same <code>Add*</code> transform variant (note they do not need to contain the same values within that variant)</li></ul><p>where <code>Add*</code> is a placeholder representing any of the typed native add operations (<code>AddInt32</code>, <code>AddInt64</code>, <code>AddInt128</code>, <code>AddInt256</code>, <code>AddInt512</code>, <code>AddKeys</code>). And they do not commute otherwise. A short summary is: reads commute, adds commute, writes conflict. Note that writes <em>always</em> conflict, even if they are writing the same value. Consider the following example:</p><div class="codeBlockContainer_J+bg language-rust theme-code-block"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = read_local(&quot;x&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if x == 7 { write_local(&quot;x&quot;, 10); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else { write_local(&quot;x&quot;, 0); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = read_local(&quot;x&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if x == 7 { write_local(&quot;x&quot;, 10); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else { write_local(&quot;x&quot;, 100); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>If the pre-state <strong><em>G</em></strong> has <code>local(&quot;x&quot;) == 7</code> then <code>f(G)</code> results in the transform <code>Write(10)</code>, and so does <code>g(G)</code>. However, if we compose <code>g(f(G))</code> then we obtain <code>Write(100)</code>, and if we compose <code>f(g(G))</code> then the result is <code>Write(0)</code> and hence the functions do not commute.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="handling-errors">Handling Errors<a class="hash-link" href="#handling-errors" title="Direct link to heading">â€‹</a></h3><p>The reason we can say &quot;adds commute&quot; in our rules is because mathematically addition is commutative. However, this relies on the infinite nature of the number line and real computers are finite. For example, if we considered the addition of three 8-bit numbers: 250, 3, and 5, any two of them can be added and they commute, but attempting to add all three results in an overflow error. Thus the final result depends on the order of addition:</p><ul><li>250 + 3 + 5 = 253 (last addition does not happen due to the error)</li><li>250 + 5 + 3 = 255</li><li>3 + 5 + 250 = 8</li></ul><p>Presently we circumvent this error by actually using modular arithmetic (wrapped addition as it is often called in computer science). Addition in modular arithmetic is still a commutative operation, so our theory holds together. In our example above 250 + 5 + 3 is always equal to 3, no matter what. However in the context of financial applications wrapping back to zero is an unexpected behavior. For this reason we use 512-bit numbers in our mint contract to represent balances, and the total number of token units (motes) available is less than <code>U512::MAX</code>, so overflow is impossible.</p><p>That said, this is not the only error which may arise due to the finite nature of computers. For example, the <code>AddKeys</code> transform is about adding elements to a map, which is a commutative operation as well (so long as none of the keys already existed in the map, then it is more akin to a write operation). Yet, this operation can also fail due to the physical machine being out of memory, thus once again meaning the order of additions could effect the final state of the map.</p><p>In a more powerful theory of parallel execution we could consider operations which fail. In this case we could say that transforms <code>t_1</code> and <code>t_2</code> commute if they are of the same addition type and the outcome of applying both to the input global state, <strong><em>G</em></strong> is not an error. This is a more complex rule because it requires doing some amount of computation during commutativity checking, whereas the previous theory was simple comparison. Yet, this theory might be worth pursuing because it solves the two problems we have listed here (overflow and out-of-memory), along with other problems that we presently cannot handle at all. For example, <code>Minus</code> could be introduced as a transform, and underflows could be handled using this refined commutativity rule. This has practical application in our system because it would mean transfers from the same source could commute if enough funds are available, whereas presently they will always be conservatively labeled as not commuting.</p><div class="footnotes"><hr><ol><li id="fn-1">There is a special case of constructing reduced traces which is worth calling out explicitly. Suppose the initial value of a key in the global state is <code>X</code>, and after performing the execution, the transform for that key is <code>Write(X)</code>. Then it is valid to replace that transform with <code>Read</code>. This is because the computation acts like the identity function (i.e. the function which makes no changes) at this key, and therefore is equal to <code>Read</code>. Notably we cannot simply remove the transform from the map because the key was still used in some way during the computation. We must have a record of what keys were used to correctly detect when deploys commute (see the following sections for more details). Replacing a <code>Write</code> with a <code>Read</code> still has great benefits for parallel execution because reads do commute with one another, while writes do not. This optimization in the reduced traces is <a href="https://github.com/casper-network/casper-node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439" target="_blank" rel="noopener noreferrer">applied in our reference implementation</a>. <sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>: Recall that committing transforms is a very fast operation relative to execution, so it causes little overhead. The main overhead would come from executing the same deploy against multiple different starting states because it failed to commute multiple times. This can be mitigated by favoring including more expensive deploys in each committed batch.<a href="#fnref-1" class="footnote-backref">â†©</a></li></ol></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/casper-network/documentation/tree/master/docs/casper/design/appendix.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/design/checksummed-hex"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Checksum Hex Encoding</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#appendix-a" class="table-of-contents__link toc-highlight">A - Casper Rust Library</a></li><li><a href="#appendix-b" class="table-of-contents__link toc-highlight">B - Serialization Format</a></li><li><a href="#appendix-c" class="table-of-contents__link toc-highlight">C - Parallel Execution</a><ul><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#computational-model-functions" class="table-of-contents__link toc-highlight">Computation as functions on the global state</a></li><li><a href="#computation-as-functions-from-g-to-endg" class="table-of-contents__link toc-highlight">Computation as functions from <strong><em>G</em></strong> to <strong><em>End(G)</em></strong></a></li><li><a href="#constructing-the-post-state-from-parallel-execution" class="table-of-contents__link toc-highlight">Constructing the post-state from parallel execution</a></li><li><a href="#detecting-when-maps-of-transforms-commute" class="table-of-contents__link toc-highlight">Detecting when maps of transforms commute</a></li><li><a href="#handling-errors" class="table-of-contents__link toc-highlight">Handling Errors</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright"><div class="footer-inner-container">
    <div class="footer-top">
        <ul class="items">
            <li><a href="https://arxiv.org/pdf/2101.02159.pdf" target="_blank" rel="noopener">White Paper</a></li>
            <li>
                <a href="https://casper.network/docs" target="_blank" rel="noopener"> Docs </a>
            </li>
            <li><a href="https://devxdao.com/" target="_blank" rel="noopener">Grant Program</a></li>
            <li><a href="https://casper.network/network/casper-association" target="_blank" rel="noopener">Casper Association</a></li>
        </ul>
    </div>
    <div class="footer-bottom">
        <ul class="items left">
            <li>
                <a href="https://casper.network/en/network" target="_blank" rel="noopener">
                    <img class="footer-logo" src="/docs/icon/logo-white.svg" alt="Casper Logo">
                </a>
            </li>
            <li>Â© 2021 Casper Association</li>
        </ul>
        <ul class="items right">
            <li class="trademark">
                <a href="https://casper.network/network/trademark-policy" target="_blank" rel="noopener">Trademark Policy and Guidelines</a>
            </li>
        </ul>
    </div>
</div>
</div></div></div></footer></div>
<script src="/docs/assets/js/runtime~main.42631c81.js"></script>
<script src="/docs/assets/js/main.b30bf4af.js"></script>
</body>
</html>